--// Services
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

--// Load Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

--// Window
local Window = Rayfield:CreateWindow({
    Name = "Pet Weight Changer V1",
    LoadingTitle = "Pet Weight Changer",
    LoadingSubtitle = "by WhosJaradd",
    ConfigurationSaving = { Enabled = false },
    Discord = { Enabled = false },
    KeySystem = false
})

--// Tabs
local MainTab = Window:CreateTab("Main", 4483362458)
local InfoTab = Window:CreateTab("Info", 4483362458)

-- Equipped Info Label
local equippedLabel = MainTab:CreateLabel("(Pet/Tool Equipped): [None]")

-- Cache original values per tool so scaling is stable and reversible
-- originalCache[tool] = { {inst = <Instance>, kind = "Mesh"/"MeshPart", original = Vector3}, ... }
local originalCache = {}

local function getEquippedTool()
	character = player.Character or player.CharacterAdded:Wait()
	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") then
			return tool
		end
	end
	return nil
end

-- Capture original scales/sizes for meshes and MeshParts inside the tool
local function captureOriginals(tool)
	if not tool or not tool.Parent then return end
	if originalCache[tool] then return end

	local list = {}
	for _, desc in ipairs(tool:GetDescendants()) do
		-- SpecialMesh / BlockMesh / FileMesh all have .Scale
		if desc:IsA("SpecialMesh") or desc:IsA("BlockMesh") or desc:IsA("FileMesh") then
			local s = desc.Scale
			if typeof(s) ~= "Vector3" then s = Vector3.new(1,1,1) end
			table.insert(list, { inst = desc, kind = "Mesh", original = s })
		-- MeshPart: store its Size (most meshparts render the visual)
		elseif desc:IsA("MeshPart") then
			local sz = desc.Size
			if typeof(sz) ~= "Vector3" then sz = Vector3.new(1,1,1) end
			table.insert(list, { inst = desc, kind = "MeshPart", original = sz })
		end
	end

	originalCache[tool] = list
end

-- Apply factor relative to originals (preserves proportions)
local function applyFactor(tool, factor)
	if not tool then return end
	captureOriginals(tool)
	local list = originalCache[tool]
	if not list or #list == 0 then return end

	for _, entry in ipairs(list) do
		-- guard: instance might be destroyed or removed
		if entry.inst and entry.inst.Parent then
			if entry.kind == "Mesh" then
				-- entry.original is the original mesh.Scale
				local orig = entry.original or Vector3.new(1,1,1)
				entry.inst.Scale = Vector3.new(orig.X * factor, orig.Y * factor, orig.Z * factor)
			elseif entry.kind == "MeshPart" then
				local orig = entry.original or Vector3.new(1,1,1)
				entry.inst.Size = Vector3.new(orig.X * factor, orig.Y * factor, orig.Z * factor)
			end
		end
	end
end

-- Reset to exact originals
local function resetToOriginal(tool)
	if not tool then return end
	local list = originalCache[tool]
	if not list then return end

	for _, entry in ipairs(list) do
		if entry.inst and entry.inst.Parent then
			if entry.kind == "Mesh" then
				entry.inst.Scale = entry.original or Vector3.new(1,1,1)
			elseif entry.kind == "MeshPart" then
				entry.inst.Size = entry.original or Vector3.new(1,1,1)
			end
		end
	end

	-- remove cache so we can recapture if tool respawns later
	originalCache[tool] = nil
end

-- UI: input and buttons
local WeightBox = MainTab:CreateInput({
	Name = "Enter Weight Factor",
	PlaceholderText = "Example: 2 (double size), 0.5 (half size)",
	RemoveTextAfterFocusLost = false,
	Callback = function(Text) end,
})

MainTab:CreateButton({
	Name = "Apply Weight",
	Callback = function()
		local tool = getEquippedTool()
		if not tool then
			equippedLabel:Set("(No Equipped Pet/Tool detected)")
			Rayfield:Notify({ Title = "Error", Content = "No equipped tool found", Duration = 2 })
			return
		end

		local txt = WeightBox.CurrentValue or WeightBox:Get()
		local factor = tonumber(txt)
		if not factor or factor <= 0 then
			equippedLabel:Set("(Enter valid weight factor)")
			Rayfield:Notify({ Title = "Error", Content = "Enter a valid number > 0", Duration = 2 })
			return
		end

		-- countdown (non-blocking feel via notifications)
		for i = 10, 1, -1 do
			Rayfield:Notify({ Title = "Applying", Content = "Applying in " .. i .. "s", Duration = 1 })
			task.wait(1)
		end

		applyFactor(tool, factor)
		equippedLabel:Set("(Applied weight factor: x" .. tostring(factor) .. ")")
		Rayfield:Notify({ Title = "Done", Content = "Applied factor x" .. tostring(factor), Duration = 2 })
	end
})

MainTab:CreateButton({
	Name = "Reset Weight",
	Callback = function()
		local tool = getEquippedTool()
		if not tool then
			equippedLabel:Set("(No Equipped Pet/Tool detected)")
			return
		end
		resetToOriginal(tool)
		equippedLabel:Set("(Reset to original)")
		Rayfield:Notify({ Title = "Reset", Content = "Restored original sizes", Duration = 2 })
	end
})

-- Live Info Update + auto-capture when new tool equipped
local lastTool = nil
task.spawn(function()
	while true do
		local tool = getEquippedTool()
		if tool then
			equippedLabel:Set("(Pet/Tool Equipped): " .. tool.Name)
			if tool ~= lastTool then
				-- capture originals for this tool on first equip
				captureOriginals(tool)
				lastTool = tool
			end
		else
			equippedLabel:Set("(No Equipped Pet/Tool detected)")
			lastTool = nil
		end
		task.wait(1)
	end
end)

-- Info Footer
InfoTab:CreateLabel("Tiktok: @WhosJaradd")
